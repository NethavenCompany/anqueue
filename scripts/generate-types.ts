#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface TaskModule {
	default: any;
	[key: string]: any;
}

interface TaskTypeInfo {
	className: string;
	dataTypeName: string;
	importPath: string;
	fileName: string;
}

export function generateClassName(filename: string): string {
	filename = filename
		.split(/[-_ ]+/)
		.map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
		.join("");

	if (!filename.endsWith("Task")) filename += "Task";

	return filename;
}

function generateDataTypeName(className: string): string {
	return `${className}Data`;
}

async function generateQueueTypes(taskDirectory: string, verbose = true, opts?: { signal: AbortSignal }): Promise<void> {
	const signal = opts?.signal;
	const throwIfAborted = () => { if (signal?.aborted) throw new Error("generateQueueTypes aborted"); };
	const projectRoot = path.resolve(__dirname, "..");
	const typesDir = path.join(projectRoot, "types");
	const queueTypesPath = path.join(typesDir, "taskdata.d.ts");
	const taskDirPath = path.join(process.cwd(), taskDirectory);

	// Ensure types directory exists
	throwIfAborted();
	if (!fs.existsSync(typesDir)) {
		fs.mkdirSync(typesDir, { recursive: true });
	}
	
	// Check if task directory exists
	throwIfAborted();
	if (!fs.existsSync(taskDirPath)) {
		console.log(
			`Task directory ${taskDirPath} does not exist. Skipping type generation.`
		);
		return;
	}
	
	// Read task directory
	throwIfAborted();
	const taskFiles = fs
	.readdirSync(taskDirPath, "utf8")
	.filter(
		(file) =>
			(file.endsWith(".ts") || file.endsWith(".js")) &&
		!file.endsWith(".test.ts") &&
		!file.endsWith(".spec.ts") &&
		!file.startsWith(".") &&
		!file.includes(".copy")
	);
	
	// Generate type information for each task
	const taskTypes: TaskTypeInfo[] = [];
	
	for (const file of taskFiles) {
		throwIfAborted();
		const fileName = path.basename(file, path.extname(file));
		const className = generateClassName(fileName);
		const dataTypeName = generateDataTypeName(className);
		const importPath = path.join(taskDirPath, fileName + ".js").replace(/\\/g, "/");

		taskTypes.push({
			className,
			dataTypeName,
			importPath,
			fileName,
		});
	}

	// Generate the queue types file content
	const imports = taskTypes
		.map(
			(task) =>
				`import type { ${task.dataTypeName} } from "${task.importPath}";`
		)
		.join("\n");

	const unionTypes = taskTypes.map((task) => task.dataTypeName).join(" | ");

	const queueTypesContent = `// This file is automatically generated. Do not edit manually.
// Run "npm run generate-types" to regenerate.

${imports}

// This type is automatically generated from task implementations:
export type TaskData = ${unionTypes || "never"};
`;

	// Write the generated types file
	throwIfAborted();
	fs.writeFileSync(queueTypesPath, queueTypesContent, { encoding: "utf8" });

	if (verbose) {
		console.log(`âœ… Generated queue types in: ${queueTypesPath}`);
		console.log(`ðŸ“ Found ${taskTypes.length} task types:`);
		taskTypes.forEach((task) => {
			console.log(`   - ${task.className} (${task.dataTypeName})`);
		});
	}
}

// CLI support
if (import.meta.url === `file://${process.argv[1]}`) {
	const taskDir = process.argv[2] || "tasks";
	generateQueueTypes(taskDir);
}

export { generateQueueTypes };
